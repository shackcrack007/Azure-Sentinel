id: 6d298375-20f7-4d01-a0ff-de1cece89425
name: Blast radius attack path analysis
description: |
    The following query (wrapped in the BlastRadiusAttackPathAnalysis function for easier repeated usage) maps and returns possible attack paths an adversary can take, starting from a device that is affected by a high severity, exploitable vulnerability (a specific CVE can be used to filter results) 
    The function receives as an input:
        sourceTypes: filter for type of device that can be considered as entry points (e.g. virtual machine, endpoint device) 
        sourceProperties: filter for properties the above devices must have (e.g. high severity vulnerabilities) 
        sourceCveIDs: filter for specific vulnerabilities (CVE IDs) the above devices must have 
        targetTypes: filter for type of device that are considered as the target of the path (e.g. storage account, privileged user, virtual machine, endpoint device) 
        targetProperties: filter for properties the target devices must have (e.g. critical assets) 
        maxPathLength: maximum hops for each attack path 
        resultCountLimit: maximum amount of attack paths calculated
query: |
    let BlastRadiusAttackPathAnalysis = (sourceTypes: dynamic, sourceProperties: dynamic, sourceCveIDs: dynamic , targetTypes: dynamic, targetProperties: dynamic , maxPathLength: long = 6, resultCountLimit: long = 10000) { 
    let edgeTypes               = pack_array
        (
                                  'can impersonate as',
                                  'has permissions to',
                                  'contains',
                                  'can authenticate as',
                                  'can authenticate to',
                                  'can remote interactive logon to',
                                  'can interactive logon to',
                                  'can logon over the network to',
                                  'contains',
                                  'has role on',
                                  'member of'
                              ); 
    let sourceNodePropertiesFormatted = strcat('(', strcat_array(sourceProperties, '|'), ')'); 
    let targetNodePropertiesFormatted = strcat('(', strcat_array(targetProperties, '|'), ')'); 
    let nodes = ( 
        ExposureGraphNodes 
        | project
            NodeId,
            NodeName,
            NodeLabel,
            SourcePropertiesExtracted = iff(sourceProperties != "[\"\"]", extract_all(sourceNodePropertiesFormatted, tostring(NodeProperties)), pack_array('')),
            TargetPropertiesExtracted = iff(targetProperties != "[\"\"]", extract_all(targetNodePropertiesFormatted, tostring(NodeProperties)), pack_array('')),
            criticalityLevel = toint(NodeProperties.rawData.criticalityLevel.criticalityLevel) 
        | mv-apply SourcePropertiesExtracted, TargetPropertiesExtracted on ( 
            summarize
                SourcePropertiesExtracted = make_set_if(SourcePropertiesExtracted, isnotempty(SourcePropertiesExtracted)),
                TargetPropertiesExtracted = make_set_if(TargetPropertiesExtracted, isnotempty(TargetPropertiesExtracted)) 
            ) 
        | extend
            CountSourceProperties = coalesce(array_length(SourcePropertiesExtracted), 0) ,
            CountTargetProperties = coalesce(array_length(TargetPropertiesExtracted), 0) 
        | extend
            SourceRelevancyByLabel = iff(NodeLabel in (sourceTypes) or sourceTypes == "[\"\"]", 1, 0) ,
            TargetRelevancyByLabel = iff(NodeLabel in (targetTypes) or targetTypes == "[\"\"]", 1, 0) ,
            SourceRelevancyByProperties = iff(CountSourceProperties > 0 or sourceProperties == "[\"\"]", 1, 0) ,
            TargetRelevancyByProperties = iff(CountTargetProperties > 0 or targetProperties == "[\"\"]", 1, 0) 
        | extend
            SourceRelevancy = iff(SourceRelevancyByLabel == 1 and SourceRelevancyByProperties == 1, 1, 0) ,
            TargetRelevancy = iff(TargetRelevancyByLabel == 1 and TargetRelevancyByProperties == 1, 1, 0) 
        ); 
    let edges = ( 
        ExposureGraphEdges 
        | where EdgeLabel in (edgeTypes) 
        | project
            EdgeId,
            EdgeLabel,
            SourceNodeId,
            SourceNodeName,
            SourceNodeLabel,
            TargetNodeId,
            TargetNodeName,
            TargetNodeLabel 
        ); 
    let vulnerableDevices = ( 
        ExposureGraphEdges 
        | where iif(sourceCveIDs == "[\"\"]", true, (SourceNodeName in (sourceCveIDs)) and (EdgeLabel == "affecting")) // filter for CVEs only if listed, otherwise return all nodes 
        | project NodeId=TargetNodeId 
        | distinct NodeId 
        ); 
    let paths = ( 
        edges 
        // Build the graph from all the nodes and edges and enrich it with node data (properties) 
        | make-graph
            SourceNodeId--> TargetNodeId with nodes on NodeId 
        // Look for existing paths between source nodes and target nodes with up to predefined number of hops 
        | graph-match cycles=none (s)-[e*1 .. maxPathLength]->(t) 
            // Filter only by paths with relevant sources and targets - filtered by node types and properties 
            where (s.SourceRelevancy == 1 and t.TargetRelevancy == 1) and s.NodeId in (vulnerableDevices) 
            project SourceName                = s.NodeName 
            , SourceType                = s.NodeLabel 
            , SourceId                  = s.NodeId 
            , SourceProperties          = s.SourcePropertiesExtracted 
            , CountSourceProperties     = s.CountSourceProperties 
            , SourceRelevancy           = s.SourceRelevancy 
            , TargetName                = t.NodeName 
            , TargetType                = t.NodeLabel 
            , TargetId                  = t.NodeId 
            , TargetProperties          = t.TargetPropertiesExtracted 
            , CountTargetProperties     = t.CountTargetProperties 
            , TargetRelevancy           = t.TargetRelevancy 
            , EdgeLabels                = e.EdgeLabel 
            , EdgeIds                   = e.EdgeId 
            , EdgeAllTargetIds          = e.TargetNodeId 
            , EdgeAllTargetNames        = e.TargetNodeId 
            , EdgeAllTargetTypes        = e.TargetNodeLabel 
        | extend
            PathLength                    = array_length(EdgeIds) + 1 
            ,
            PathId                        = hash_md5(strcat(SourceId, strcat(EdgeIds), TargetId)) 
        ); 
    let relevantPaths = ( 
        paths 
        | extend
            NodesInPath = array_concat(pack_array(SourceId), EdgeAllTargetIds),
            NodeLabelsInPath = array_concat(pack_array(SourceType), EdgeAllTargetTypes) 
        | extend NodesInPathList = NodesInPath 
        // Wrap the path into meaningful format (can be tweaked as needed) 
        | mv-expand with_itemindex = SortIndex
            EdgeIds to typeof(string),
            EdgeLabels to typeof(string),
            NodesInPath to typeof(string),
            NodeLabelsInPath to typeof(string) 
        | sort by PathId, SortIndex asc 
        | extend step = strcat
            ( 
                            iff(isnotempty(NodesInPath), strcat('(', NodeLabelsInPath, ' ', SourceName, ':', NodesInPath, ')'), '') ,
                            iff(CountSourceProperties > 0 and NodesInPath == SourceId, SourceProperties, '') ,
                            iff(CountTargetProperties > 0 and NodesInPath == TargetId, TargetProperties, '') ,
                            iff(isnotempty(EdgeLabels), strcat('-', EdgeLabels, '->'), '')
            ) 
        | summarize Path = make_list(step), take_any(*) by PathId 
        // Project relevant fields 
        | project
            SourceName,
            SourceType,
            SourceId,
            SourceProperties,
            CountSourceProperties,
            SourceRelevancy,
            TargetName,
            TargetType,
            TargetId,
            TargetProperties,
            CountTargetProperties,
            TargetRelevancy,
            PathId,
            PathLength,
            Path 
        | top resultCountLimit by PathLength asc 
        ); 
    relevantPaths 
    }; 
    // Calling the function
    let sourceTypes         = pack_array('microsoft.compute/virtualmachines', 'compute.instances', 'ec2.instance', 'device', 'container-image', 'microsoft.hybridcompute/machines'); 
    let sourceProperties    = pack_array('hasHighOrCritical'); // filter for assets with severe vulnerabilities 
    let sourceCveIDs        = pack_array('CVE-2024-6387'); // filter for entry points with the CVE, in this example it's OpenSSH regSSHion vulnerability
    let targetTypes         = pack_array('');  
    let targetProperties    = pack_array('criticalityLevel'); // filter for paths that ends with critical assets 
    BlastRadiusAttackPathAnalysis(sourceTypes, sourceProperties, sourceCveIDs, targetTypes, targetProperties) 
    | project-reorder SourceType, SourceName, TargetType, TargetName, Path 
    | project-keep SourceType, SourceName, TargetType, TargetName, Path 
